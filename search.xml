<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Cocoapods 修改Pod 编译选项]]></title>
      <url>%2F2017%2F03%2F17%2FCocoapods%20%E4%BF%AE%E6%94%B9Pod%20%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%2F</url>
      <content type="text"><![CDATA[公司项目一直使用的是私有Spec 仓库来管理每个业务模块，每个模块单独为一个Pod。但是最近发现个问题，就是即使方法声明了需要有返回值，但是如果不写return 的话，编译竟然也不会报错 于是查看编译选项 发现target 的Mismatched Return Type 值是Yes,而如果改成Yes(Treat as Error) 之后，则会正常报错。所以我们需要想方法来修改这个编译选项 Podspec.podspec 文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。所以我们只有修改.podspec 就可以了，查了下文档 pod_target_xcconfig 表示pod 本身被依赖时，修改的编译选项 user_target_xcconfig 表示修改依赖pod 的项目的编译选项 用编辑器打开项目文件Pods.xcodeproj，查找该编译选项的Key，也可以在这里查看 发现Key 为GCC_WARN_ABOUT_RETURN_TYPE，值为YES_ERROR&#39; 正解在.podspec 文件里增加下面这行即可 1spec.pod_target_xcconfig = &#123;'GCC_WARN_ABOUT_RETURN_TYPE' =&gt; 'YES_ERROR'&#125; 参考 深入理解 CocoaPodsPodspec Syntax Reference]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[滑动视图导航控制器]]></title>
      <url>%2F2017%2F02%2F28%2F%E6%BB%91%E5%8A%A8%E8%A7%86%E5%9B%BE%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%2F</url>
      <content type="text"><![CDATA[这两天趁着在公司里继续做着不爱做的需求的空隙，将很多App 常用的滑动视图控制器按照自己的想法造了个轮子，在这记录下整个流程。 Demo 地址GitHub 演示： 介绍1.CocoaPods1pod &apos;JCPageController&apos; 2.Demo 使用12345678910111213141516171819202122232425262728293031323334353637//创建pageController- (JCPageContoller *)pageController&#123; if (!_pageController) &#123; _pageController = [[JCPageContoller alloc]init]; _pageController.delegate = self; _pageController.dataSource = self; [self addChildViewController:_pageController]; [self.view addSubview:_pageController.view]; _pageController.lineAinimationType = self.lineAinimationType; _pageController.scaleSelectedBar = self.scaleSelectedBar; &#125; return _pageController;&#125;- (NSInteger)numberOfControllersInPageController&#123; return count;&#125;- (NSString *)reuseIdentifierForControllerAtIndex:(NSInteger)index;&#123; return identifier;//用于controller重用&#125;- (UIViewController *)pageContoller:(JCPageContoller *)pageContoller controllerAtIndex:(NSInteger)index&#123; UIViewController *controller = [pageContoller dequeueReusableControllerWithReuseIdentifier:identifier atIndex:index];//获取重用的controller if (!controller) &#123; //controller init &#125; return controller;&#125;- (CGFloat)pageContoller:(JCPageContoller *)pageContoller widthForCellAtIndex:(NSInteger )index&#123; return width;&#125;- (NSString *)pageContoller:(JCPageContoller *)pageContoller titleForCellAtIndex:(NSInteger)index&#123; return text;&#125; 更多使用方法请看Demo 原理构成主要分两个部分： 上方的TabBar（UICollectionView 构成） 下方的容器ContentView（UIScrollView 构成） 12@property (nonatomic, strong) JCPageSlideBar *slideBar;@property (nonatomic, strong) UIScrollView *contentView; 目录结构 流程 通过数据源获取子Controller 的数量，以及相应索引上tabBar 的宽度和title。 通过数据源获取相应索引上的Controller，先判断如果有相同identifier 的可复用Controller，若有，则返回，否则创建该Controller，存入到缓存中。 当手势滑动ContentView 或点击TabBar 来切换页面时，处理ContentView 与TabBar 之间的协同问题。 主要逻辑首先是重用Controller，这个对提高性能很重要，我是将Controller 都存到controllersMap 这个字典里，用 @“index_identifier” 来当做key，同一个identifier 的Controller 最多创建两个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@property (nonatomic, strong) NSMutableDictionary *controllersMap; //用于保存controllers 用 @“index_identifier” 来当做key value为controller- (UIViewController *)dequeueReusableControllerWithReuseIdentifier:(NSString *)identifier atIndex:(NSInteger)index&#123; if (!identifier) &#123; return nil; &#125; NSInteger count = [self.dataSource numberOfControllersInPageController]; if (index &gt;= count || index &lt; 0) &#123; return nil; &#125; UIViewController *controller = nil; NSString *findKey = nil; for (NSString *key in self.controllersMap) &#123; NSArray *components = [key componentsSeparatedByString:@"_"]; NSString *indexStr = components.firstObject; NSString *identifierStr = components.lastObject; NSInteger gap = labs(indexStr.integerValue - index); if (self.didSelectBarToChangePage) &#123; //点击tabbar切换页面 if ([identifier isEqualToString:identifierStr]) &#123; if (self.currentIndex != indexStr.integerValue) &#123; controller = self.controllersMap[key]; findKey = key; break; &#125; &#125; &#125;else&#123; //手势滑动切换页面 if ([identifier isEqualToString:identifierStr] &amp;&amp; gap &gt; 1) &#123; controller = self.controllersMap[key]; findKey = key; break; &#125; &#125; &#125; if (findKey) &#123; if ([controller respondsToSelector:@selector(prepareForReuse)]) &#123; [controller performSelector:@selector(prepareForReuse)]; &#125; [self.controllersMap removeObjectForKey:findKey]; &#125;else&#123; if ([self getControllerFromMap:index]) &#123; controller = [self getControllerFromMap:index]; &#125; &#125; return controller;&#125; 为了性能考虑，只有当每次滑动即将出现某个index 对应的Controller 时，才去创建该Controller，将其add 到ContentView 相应的ContentOffset 上的。 手势滑动切换页面时，主要逻辑在scrollViewDidScroll这个方法里，先判断滑动方向，然后配置相应的Controller。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; ... BOOL scrollToRight = YES; if (contentOffsetX - self.lastOffsetX &gt; 0) &#123; if (contentOffsetX &lt;= curControllerOriginX) &#123; return; &#125; nextPage = page &lt; totalCount - 1 ? page + 1 : totalCount - 1; &#125;else&#123; if (contentOffsetX &gt;= curControllerOriginX) &#123; return; &#125; scrollToRight = NO; page = page &lt; totalCount - 1 ? page+1 : totalCount-1; nextPage = page &gt; 0 ? page - 1 : 0; &#125; self.lastOffsetX = contentOffsetX; if (self.currentIndex != page) &#123; //配置当前显示的controller self.currentIndex = page; self.currentController = self.nextController; [self.slideBar selectTabAtIndex:self.currentIndex]; &#125; //配置下个将要显示的controller [self checkNeedConfigNextPage:scrollToRight nextPage:nextPage];&#125;- (void)checkNeedConfigNextPage:(BOOL)scrollToRight nextPage:(NSInteger)nextPage&#123; CGFloat contentOffsetX = self.contentView.contentOffset.x; BOOL needConfigNextPage = NO; if (scrollToRight) &#123; if (contentOffsetX &gt; self.currentIndex * self.contentView.frame.size.width) &#123; needConfigNextPage = YES; &#125; &#125;else&#123; if (contentOffsetX &lt; self.currentIndex * self.contentView.frame.size.width) &#123; needConfigNextPage = YES; &#125; &#125; if (needConfigNextPage &amp;&amp; self.nextIndex != nextPage) &#123; //配置下一个即将显示的controller [self willDraggingToNextController:nextPage]; &#125;&#125; 当点击tabBar 切换页面时，主要实现JCPageSlideBarDelegate 代理方法，将nextVCL 放在当前Controller 相邻位置上，待滚动结束后在恢复真正位置。 123456789101112131415- (void)pageSlideBar:(JCPageSlideBar *)pageSlideBar didSelectBarAtIndex:(NSInteger)index&#123; ... self.selectBarIndex = index; NSInteger realIndex = self.currentIndex &lt; index ? self.currentIndex + 1 : self.currentIndex - 1; UIViewController *nextVCL = [self willDraggingToNextController:index]; if (nextVCL) &#123; //将nextVCL 放在相邻位置上，待滚动结束后在恢复真正位置 self.contentView.userInteractionEnabled = NO;//滚动期间 不允许用户手势操作 self.currentController = nextVCL; CGRect rect = nextVCL.view.frame; rect.origin.x = realIndex * self.contentView.frame.size.width; nextVCL.view.frame = rect; &#125; [self.contentView setContentOffset:CGPointMake(realIndex * self.contentView.frame.size.width,0) animated:YES];&#125; 默认提供了四种line 的切换动画 123456typedef NS_ENUM(NSUInteger, JCSlideBarLineAnimationType) &#123; JCSlideBarLineAnimationFixedWidth = 0, //固定宽度 JCSlideBarLineAnimationDynamicWidth = 1, //动态宽度，与标题文字等宽 JCSlideBarLineAnimationStretchFixedWidth = 2, //拉伸效果 固定宽度 JCSlideBarLineAnimationStretchDynamicWidth = 3, //拉伸效果 动态宽度，与标题文字等宽&#125;; 其中拉伸效果需要计算当前切换页面滑动的progress ，以此来计算line 的origin.x 以及width。 这里也提供了tabBar 选中放大效果以及title 颜色渐变，,主要使用的是CGAffineTransformMakeScale， 1@property (nonatomic) BOOL scaleSelectedBar;//是否有选中放大效果 1234567891011121314151617181920212223242526- (void)scaleTitleFromIndex:(NSInteger)fromIndex toIndex:(NSInteger)toIndex progress:(CGFloat)progress&#123; if (!self.scaleSelectedBar) &#123; return; &#125; CGFloat scale = kSlideBarCellScaleSize; CGFloat currentTransform = (scale - 1) * progress; UICollectionViewCell *fromCell = [self.collectionView cellForItemAtIndexPath:[NSIndexPath indexPathForItem:fromIndex inSection:0]]; UICollectionViewCell *toCell = [self.collectionView cellForItemAtIndexPath:[NSIndexPath indexPathForItem:toIndex inSection:0]]; fromCell.transform = CGAffineTransformMakeScale(scale - currentTransform , scale - currentTransform); toCell.transform = CGAffineTransformMakeScale(1 + currentTransform, 1 + currentTransform); if (self.lineAinimationType &lt; JCSlideBarLineAnimationStretchFixedWidth) &#123; //不是拉伸效果就不用变颜色了 return; &#125; CGFloat narR,narG,narB,narA; [kTitleNormalColor getRed:&amp;narR green:&amp;narG blue:&amp;narB alpha:&amp;narA]; CGFloat selR,selG,selB,selA; [kTitleSelectedColor getRed:&amp;selR green:&amp;selG blue:&amp;selB alpha:&amp;selA]; CGFloat detalR = narR - selR ,detalG = narG - selG,detalB = narB - selB,detalA = narA - selA; UILabel *fromTitle = [fromCell viewWithTag:kSlideBarCellTitleTag]; UILabel *toTitle = [toCell viewWithTag:kSlideBarCellTitleTag]; fromTitle.textColor = [UIColor colorWithRed:selR + detalR * progress green:selG+detalG * progress blue:selB+detalB * progress alpha:selA+detalA * progress]; toTitle.textColor = [UIColor colorWithRed:narR-detalR * progress green:narG-detalG * progress blue:narB-detalB * progress alpha:narA-detalA * progress];&#125; 总结由于自身的能力以及是第一版，尚且存在很多不足之处，例如不能自由的定制化，代码注释不够，一些方法逻辑躲起来不够顺畅，总的来说还是可以满足基本需求。日后有时间将会继续完善。欢迎大家指出问题，一起交流。 Demo 地址GitHub]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[轮播图不同实现方法 以及 发布到Cocoapod]]></title>
      <url>%2F2017%2F02%2F20%2F%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%AE%9E%E7%8E%B0%20%E4%BB%A5%E5%8F%8A%E5%8F%91%E5%B8%83%E5%88%B0Cocoapod%2F</url>
      <content type="text"><![CDATA[Demo地址github 周末闲着无聊把使用两个UIImageView 以及使用一个UIImageView 来实现轮播图分别写了一下，顺便试了下发布到Cocoapod，总体来说还是很简单的，记录下流程。 两个UIImageView原理和使用三个基本一样，没什么可以说的 使用的demo1234567891011121314151617181920212223242526- (void)demo&#123; JCCarouselView *bannerView = [[JCCarouselView alloc]initWithFrame:CGRectMake(0, 64, self.view.frame.size.width, 220)]; [self.view addSubview:bannerView]; bannerView.imageUrlArr = self.imageUrlArr; bannerView.placeholderImage = [UIImage imageNamed:@"placeholder"]; //设置pagecontrol 图片 bannerView.curPageControlImage = [UIImage imageNamed:@"Group"]; bannerView.pageControlImage = [UIImage imageNamed:@"Group1"]; //设置pagecontrol 颜色 bannerView.pageControlColor = [UIColor whiteColor]; bannerView.curPageControlColor = [UIColor redColor]; bannerView.timeInterval = 4; bannerView.delegate = self; bannerView.clickBlock = ^(NSInteger index)&#123; NSLog(@"点击%ld张图片",index); &#125;;&#125;- (void)carouselView:(JCCarouselView *)carouselView didSelectedAtIndex:(NSInteger)index&#123; NSLog(@"点击%ld张图片",index);&#125; 一个UIImageView主要原理是使用CATransition 这个类，往图片上添加转场效果。 先在图片上添加左滑以及右滑的手势 123456789101112131415161718- (UIImageView *)imageView&#123; if (!_imageView) &#123; _imageView = [[UIImageView alloc]initWithFrame:self.bounds]; [self addSubview:_imageView]; [_imageView setContentMode:UIViewContentModeScaleAspectFill]; _imageView.clipsToBounds = YES; _imageView.userInteractionEnabled = YES; UISwipeGestureRecognizer *leftSwipeGesture = [[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(leftSwipe:)]; leftSwipeGesture.direction = UISwipeGestureRecognizerDirectionLeft; [_imageView addGestureRecognizer:leftSwipeGesture]; UISwipeGestureRecognizer *rightSwipeGesture = [[UISwipeGestureRecognizer alloc]initWithTarget:self action:@selector(rightSwipe:)]; rightSwipeGesture.direction = UISwipeGestureRecognizerDirectionRight; [_imageView addGestureRecognizer:rightSwipeGesture]; &#125; return _imageView;&#125; 滑动的实现方法 12345678910111213141516171819202122232425-(void)transitionAnimation:(NSInteger)direction&#123; CATransition *transition=[[CATransition alloc]init]; transition.type= kCATransitionPush;//@"rippleEffect"; BOOL right = YES; //设置子类型 if (direction == JCCarouselDirectionLeft) &#123; transition.subtype=kCATransitionFromRight; &#125;else if (direction == JCCarouselDirectionRight) &#123; transition.subtype=kCATransitionFromLeft; right = NO; &#125; transition.duration = .25f; if (right) &#123; self.curIndex=(_curIndex + 1) % self.imageUrlArr.count; &#125;else&#123; self.curIndex=(_curIndex - 1 + self.imageUrlArr.count) % self.imageUrlArr.count; &#125; [self.imageView sd_setImageWithURL:self.imageUrlArr[self.curIndex]]; [self.imageView.layer addAnimation:transition forKey:@"KCTransitionAnimation"];&#125; 这种方法的局限在于不能跟随手势滑动，只要滑动就会立刻切换图片，实用性不大，不过了解下CATransition 这个类还是很有好处的。 发布到Cocoapod1.打tag12git tag -a 1.0.0 -m&quot;1.0.0&quot;git push --tags 2.创建项目的podspec文件1pod spec create JCCarouselView 这时会生成JCCarouselView.podspec 文件，这就相当于你的库的描述文件，语法参照这里填写即可 123456789101112131415161718192021222324Pod::Spec.new do |s| s.name = &quot;JCCarouselView&quot; s.version = &quot;1.0.4&quot; s.summary = &quot;两个UIImageView实现的轮播banner&quot; s.homepage = &quot;https://github.com/JiachengZheng/JCCarouselView&quot; s.license = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125; s.author = &#123; &quot;zhengjiacheng&quot; =&gt; &quot;jiachengzheng@163.com&quot; &#125; s.platform = :ios, &quot;7.0&quot; s.ios.deployment_target = &quot;7.0&quot; s.source = &#123; :git =&gt; &apos;https://github.com/JiachengZheng/JCCarouselView.git&apos;, :tag =&gt; s.version &#125; s.source_files = &apos;JCCarouselView/*.&#123;h,m&#125;&apos; # s.resource = &quot;icon.png&quot; # s.resources = &quot;Resources/*.png&quot; s.public_header_files = &apos;JCCarouselView/*.h&apos; s.requires_arc = true # s.xcconfig = &#123; &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SDKROOT)/usr/include/libxml2&quot; &#125; s.dependency &apos;SDWebImage&apos;end 3.验证podspec文件1pod spec lint JCCarouselView.podspec 不知道为什么总会提示报错 12345678910Updating spec repo `master`Validating podspec -&gt; JCCarouselView (1.0.2) - ERROR | [iOS] xcodebuild: Returned an unsuccessful exit code. You can use `--verbose` for more information. - ERROR | xcodebuild: /Users/zhengjiacheng/Library/Developer/Xcode/DerivedData/App-dvilxxenwfwalycxbchznfaznvzq/Build/Products/Release-iphonesimulator/JCCarouselView/JCCarouselView.framework/Headers/JCCarouselView.h:10:9: error: include of non-modular header inside framework module &apos;JCCarouselView.JCCarouselView&apos; [-Werror,-Wnon-modular-include-in-framework-module] - NOTE | xcodebuild: /var/folders/8j/zd9r7fv92wz32qbj6dhk70n80000gn/T/CocoaPods/Lint/App/main.m:3:9: fatal error: could not build module &apos;JCCarouselView&apos;[!] The spec did not pass validation, due to 2 errors.[!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run: `echo &quot;2.3&quot; &gt; .swift-version`. 后来改为 1pod spec lint JCCarouselView.podspec --use-libraries 就可以了，不太知道原因。。。 如果出现 12345 -&gt; JCCarouselView (1.0.2)Analyzed 1 podspec.JCCarouselView.podspec passed validation. 就代表成功了 4.上传podspec首先需要注册 1pod trunk register xxxxxx@gmail.com &apos;MrSong&apos; --description=&apos;MrSong&apos; 随后邮箱里会发确认邮件，确认以后就可上传了可通过 pod trunk me 查看自己是否注册成功 之后就可以上传了，这一步可能会比较慢 1pod trunk push JCCarouselView.podspec --use-libraries 后面还是加上了--use-libraries防止报错。。。 出现如下代码上传成功 123456🎉 Congrats🚀 JCCarouselView (1.0.2) successfully published📅 February 6th, 02:16🌎 https://cocoapods.org/pods/JCCarouselView👍 Tell your friends! 5.验证1pod search &apos;JCCarouselView&apos; 大功告成！Enjoy! Demo地址github]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AFNetworking 踩坑]]></title>
      <url>%2F2017%2F01%2F20%2FAFNetworking%20%E8%B8%A9%E5%9D%91%2F</url>
      <content type="text"><![CDATA[最近公司的项目把网络库从ASIHTTPRequest 全部替换成了AFNetworking，但是在iOS 7上遇到了频率很高的crash。具体崩溃在AFURLSessionManager.h里的[self.mutableData appendData:data];这一行 123456- (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; [self.mutableData appendData:data];&#125; 打印的log 12malloc: *** error for object 0x633c000: pointer being freed was not allocated*** set a breakpoint in malloc_error_break to debug 意思应该是mutableData在某处被释放了，于是查找所有用到mutableData的地方 1234567891011- (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123;... NSData *data = nil; if (self.mutableData) &#123; data = [self.mutableData copy]; self.mutableData = nil; &#125;...&#125; 在这个回调里mutableData 被释放掉了，但是在iOS 7以上的系统却没发现崩溃，应该是iOS 7里，同一个task，这两个方法是在两个线程异步执行的，导致mutableData 提前置为nil。 解决办法在操作mutableData的地方加锁，并且加了版本判断，崩溃就基本不会复现了。 123456789101112131415- (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; if ([[[UIDevice currentDevice] systemVersion] floatValue] &lt; 8.0) &#123; @synchronized (self.mutableData) &#123; if (!self.mutableData) &#123; self.mutableData = [NSMutableData data]; &#125; [self.mutableData appendData:data]; &#125; &#125;else&#123; [self.mutableData appendData:data]; &#125;&#125; 12345678910111213141516171819- (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123;... NSData *data = nil; if (self.mutableData) &#123; data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. if ([[[UIDevice currentDevice] systemVersion] floatValue] &lt; 8.0) &#123;//加锁，防止崩溃在[self.mutableData appendData:data]; @synchronized (self.mutableData) &#123; self.mutableData = nil; &#125; &#125;else&#123; self.mutableData = nil; &#125; &#125;...&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016年 总结]]></title>
      <url>%2F2017%2F01%2F02%2F2016%E5%B9%B4%20%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[2016年，我的23岁。这一年发生了很多，无论在工作上、还是在生活上，这都将是意义重大的一年。现在是元旦假期的最后一天，自己在家，还有一条金毛，乖乖。虽然把公司的电脑带回了家，原本是想在家可以好好写写代码，不要荒废时间，毕竟最近的需求多的可以，然而排期的时间却没有多久，但是，一个人在家却无心编代码。2016就这么不知不觉地过去了，从小到大也没有写日记，写总结的习惯，导致很多的事情发生过了也就忘了，也没有从中总结、反思，所以决心写点东西，算是记录自己的2016年，展望2017吧。 前言前一段时间开始学着用Markdown 来写笔记，用GitHub 生成自己的博客，也会在简书上同步自己的文章，希望以此push 下自己去记录遇到的问题，以及分享自己的心得。看到简书上的阅读量以及点赞数一天天在增加，虽然还是很少，不过这也是很满足的，感觉自己写的东西被别人认可，希望以后能更多的输出更有价值的文章。 工作在公司从实习一直到现在差不多2年了，庆幸自己赶上了iOS 行业市场的尾巴，也庆幸媳妇儿能一起被录用，能一起工作，一起上下班，虐了多少单身汪。虽然最近iOS 行情很不好，但我认为这只是对初学者的要求越来越高，我相信以自己的能力，还是能够找到一份不错的工作。 在平常做业务需求上，跟着我们老大学了不少东西，对整个项目各个模块也越来越熟悉，在整体项目架构理解上也有一定程度的提高。刚来公司由于做的需求很少，觉得很焦虑，整天看博客，做自己的demo，后来需求多了，又开始认为天天做业务需求对自己的技术水平提高不了太多，也很焦虑。后来自己也想明白了，技术需要自己一点点积累，做业务需求也一样，能把需求做的很好，也是一件很难的事情。需要把代码写的尽量优雅，易于维护，修改，适应不同的需求变更。没有太多需求的时候也不能偷懒，多看看一些开源的代码，试着自己模仿着写出来。 最近写的需求涉及到了自己在实习期写的模块的代码，由于刚来公司，第一次接触企业级的代码，啥也不懂，现在回头看来自己当初写的代码简直恶心到不行，趁着做需求的间隙，把整个模块的代码重构了一遍，现在看的要舒服多了，不过再过两个月，估计回头再看可能还是觉得恶心。 由于公司太抠，只配备了一台13寸的pro ，屏幕太小，于是自己掏腰包买了一台DELL P2415Q 4k 23寸的显示器，现在双屏工作效率以及幸福感都大大提升，加上整洁的桌面，每天上班的心情也会变好，也有助于代码的整洁性。每天下班的时候也坚持把椅子推回到桌子里面，这样也与人方便。并且现在也养成了买正版的习惯，看到好的软件，会不犹豫直接买下，不再为了盗版折腾，直接享受正版带来的便捷。 生活 今年，我结束了单身生活，在5.27号领了证，6月份请了婚假和媳妇儿一起去了趟马尔代夫，因为这是她小时候的梦想。这是第一次出国，坐了很长时间的飞机，现在想起在马尔代夫的日子，感觉很不真实，希望以后还有机会去玩。 年初时，特地坐了8个小时汽车从沈阳带回了一只小金毛，叫做乖乖。从此开始了我的铲屎之旅，刚带回家还不到两个月，现在已经整整一岁了，现在就躺在我的脚底下睡觉呢。从刚到家每天晚上折腾我到现在在家已经老实多了，就是一出去玩还是疯的不行，属于撒手没类型。现在每天早上基本不需要闹钟，8点准时被它叫醒，多冷都得带出去溜两圈。哎，自己决定养的狗，跪着也要溜完它。不过乖乖还是带来了很多欢乐，每天回家它都兴奋地扑向我们，希望它能这么一直健健康康，快快乐乐地度过一生。 10月份在举办了一场草坪婚礼，只邀请了同学。虽然到场的人不多，大家都跑到全国世界各地，有些人甚至可能这辈子也没有交集了，但是还是很感谢能到场来的人。草坪婚礼也是满足了媳妇的愿望，希望自己能履行自己的诺言，经常带媳妇出去玩，吃好吃的，一直都幸福着。 现在在北京租的是自如，离公司不到3公里的地方，一个月3000，虽然挺贵，但节省了上下班的时间，觉得还是很值的，不必每天挤地铁，可以睡懒觉。冬天下班嫌冷也可以随便打车回家，不必心疼打车钱。等我弟今年大四毕业了打算整租一套两居，这样生活上会比较方便，至少乖乖有人带了，哈哈。 阅读今年难得买了一个kindle ，想督促自己多读读书，不过好像也没读多少，现在也快积灰了，希望2017年能多读点书，提高自己的内在。列一下今年读的书： 《三体》三部曲 《追风筝的人》 《无声告白》 《阿弥陀佛么么哒》 《乖，摸摸头》 《解忧杂货店》 《白夜行》 《嫌疑人x的献身》 《Effective Objective-C 2.0》 《iOS 开发进阶》 《iOS 编程》 运动不知不觉已经步入职场两年了，毕业了以后就很难再找到能很爽地在一起打球的球友了，篮球也渐渐荒废了。公司里虽然也有人打，但不多，水平也一般，只能周末和我弟在他学校里打球了。现在的身体早已不复当年，但还是会不服输的打下去，偶尔也会惊艳一下。现在也只有打篮球能痛快的运动一下了，平常就是早晚的遛狗，制定的步数目标是8000步。在公司组织的投篮比赛中，我和媳妇儿还一起参加，最后得了第一名，奖品是小米手环和一个篮球，还是很骄傲的，想当前在大学的时候我们俩也参加了篮球比赛还拿了第二。公司里还有乒乓球台，午休吃完饭有时间就会拖着媳妇陪我打乒乓球，虽然技术很一般，但是也会不断地练习，不断的进步。 目标 &amp; 展望 练字，自己的字写的太差了，是时候该练练字了 英语，编程需要英语，以后出国玩还得靠英语 读书，把kindle 利用起来 运动，篮球、乒乓球 在GitHub 上能有能拿得出手的开源项目。 项目里UICollectionView使用框架 横划组件 学习开源的代码，YYKit、SDWebImage 刷刷LeetCode，整理到GitHub 上 踏实做需求，争取做到最好 写有价值的博客 旅游，至少两个城市 涨薪两次 学习Python以及Shell 加深对GCD、Runloop、Runtime、锁的理解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 面试]]></title>
      <url>%2F2016%2F12%2F24%2F%E9%9D%A2%E8%AF%95%2F</url>
      <content type="text"><![CDATA[前一阵在趣直播平台上看了我就叫Sunny怎么了 大神的iOS 面试小灶直播，总结下直播的内容。 简历中的问题1.项目描述过于简单宽泛 项目规模？ 你在其中的职责 详细介绍使用的技术 遇到的问题、坑以及如何解决的？ 2.专业技能前篇一律 在列举技术名词时最好写出用这个技术干了什么？ 比如“熟练应用Objc runtime 技术，曾使用它做了ViewController 进入和退出时的AOP 埋点” 3.格式、拼写、细节 Object-C Foudation ios xCode 4.提供更多的信息来体现你的特别 Blog GitHub 技术探索 对技术的个人理解 做过什么有意思的事儿 我就叫Sunny怎么了 的一般套路 最近的工作，App，负责哪些模块（考察前一份工作的难度） 找个最熟悉的业务，描述一下设计结构，UI层级，控件的使用，布局，交互效果等（考察基本业务能力，熟练程度，质量） 考察几个基础的问题，如内存管理，多线程 从简历里熟练或掌握的技术中找几个深聊 找面试者研究过的，有心得或熟练的东西聊 考虑更深度的问题 沟通是否顺畅 几个面试题property @property 能使用哪些关键字及作用是什么？ 答： 属性 作用 strong 释放旧对象将旧对象的值赋予输入对象，再提高输入对象的索引计数为1 weak weak不增加对对象的引用计数，也不持有对象，因此不能决定对象的释放。它比assign多了一个功能，当对象消失后自动把指针变成nil assign 简单赋值，不更改索引计数，适用于基础数据类型（NSInteger CGFloat）和C数据类型（int float double char 等）简单数据类型 copy 对应mutableCopy。此属性只对那些实行了NSCopying协议的对象类型有效。根据调用类型不同，决定是深拷贝还是浅拷贝，一般都是浅拷贝，只复制了指针，内容还是同一份 atomic 和 nonatomic用来决定编译器生成的getter和setter是否为原子操作，atomic 设置成员变量的@property属性时 默认为是atomic 提供线程安全。在多线程环境下，原子操作是必要的否则会引起错误的结果。 nonatomic 非原子性访问对于属性赋值的时候不加锁，多线程并发访问会提高性能，如果不加此属性则默认是两个访问方法都为原子型事务访问。 readonly 此标记说明属性是只读的 readwrite 此标记说明属性会被当成读写的 这也是默认的属性 unsafe_unretained 跟weak类似，声明一个弱引用，但是当引用计数为0时，变量不会自动设置为nil getter 指定 get 方法，并需要实现这个方法。必须返回与声明类型相同的变量，没有参数 setter 指定 set 方法，并需要实现这个方法。带一个与声明类型相同的参数，没有返回值（返回空值） 下面这4种写法的区别 1234@property (nonatomic, strong) NSArray *array0;@property (nonatomic, copy) NSArray *array1;@property (nonatomic, strong) NSMutableArray *array2;@property (nonatomic, copy) NSMutableArray *array3; 答：array0如果传进来的是mutableArray ，如果里面元素被改变的话，会可能出现问题；array1标准写法，当传经来的是mutableArr时，会变成不可变版本，但里面元素不会复制一份，都是浅拷贝；array2是标准写法；array3当设置时，会被变成不可变版本，后续如果调用mutableArr的消息，会导致crash； 基本内存管理下面对象分别在什么时候释放？ 1234567891011- (void)ARCProblem&#123; id obj0 = @"sunny"; __weak id obj1 = obj0; id obj2 = [NSObject new]; __weak id obj3 = [NSObject new]; &#123; id obj4 = [NSObject new]; &#125; __autoreleasing id obj5 = [NSObject new]; __unsafe_unretained id obj6 = self;&#125; obj0 是一个字符串，分配在常量区，所以不会释放 obj1 是weak 指向obj0 会生成一个map 来映射对象和指针的关系，当对象释放时，会反向查找所有的指针，将指针置为nil。这里obj0 是个常量，不会被释放，所以obj1不会释放 obj2 当对象用完就会释放 obj3 这行语句结束就会释放 obj4 定义在一个scope里，scope结束就会释放 obj5 会加到自动释放池中，会在最近的AutoreleasePool pop被释放 obj6 可能随时都会被释放 UIViewController这样写会发生什么？ 1234- (void)viewDidLoad &#123; [super viewDidLoad]; self.view = nil;&#125; 第一次self.view 时会调用loadView方法加载view ，当加载结束后会调用viewDidLoad。有可能递归调用，但是如果之后没有操作self.view 就不会递归，屏幕上回黑屏。 UITableViewUITableViewDataSource 和 UITableViewDelegate 中的主要方法有哪些，调用顺序和时机是怎样的？ block 内存管理如何解决下面代码的问题 12345- (void)blockRetailCycleProblem&#123; self.block = ^&#123; NSLog(@"%@",@[self]); &#125;&#125; 解决方案： 123456- (void)blockRetainCycleAnswer0&#123; __weak typeof(self) weakSelf; self.block = ^&#123; NSLog(@"%@",@[weakSelf]); &#125;&#125; 1234567- (void)blockRetainCycleAnswer1&#123; __weak typeof(self) weakSelf; self.block = ^&#123; __weak typeof(weakSelf) strongSelf = weakSelf; NSLog(@"%@",@[weakSelf]); &#125;&#125; 123456789- (void)blockRetainCycleAnswer2&#123; __weak typeof(self) weakSelf; self.block = ^&#123; __weak typeof(weakSelf) strongSelf = weakSelf; if(strongSelf)&#123; NSLog(@"%@",@[strongSelf]); &#125; &#125;&#125; 前两种都有weakself 都有提前被释放的可能，会导致crash，第三种比较全面 block 内存管理 Extension下面的 self 用不用 weak ？ 12345- (void)blockRetainCycleProblemExt&#123; [UIView animateWithDuration:1 animations:^&#123; self.view.frame = CGRectMake(1,2,3,4); &#125;]&#125; 那这个呢？ 123[UIView animateWithDuration:1 delay:10000 options:0 animations:^&#123; self.view.frame = CGRectMake(1,2,3,4);&#125;] 动画block 是瞬间执行的，不会持有self的 代码规范改错123456789101112131415typedef enum&#123; UserSex_Man, UserSex_woman&#125;UserSex;@interface UserModel : NSObject@property(nonatomic, strong) NSString* name;@property (assign, nonatomic) int age;@property (nonatomic, assign) UserSex sex;- (id)initUserModelWithUserName:(NSString*)name withAge:(int)age;- (void)doLogin;@end 修改如下： 1234567891011121314151617181920typedef NS_ENUM(NSUInteger, XXUserGender)&#123; XXUserGenderUndefine, XXUserGenderMale, XXUserGenderFemale, XXUserGenderSark&#125;;@interface XXUserModel : NSObject@property (nonatomic, copy) NSString* identifier;@property (nonatomic, copy) NSString* name;@property (nonatomic, assign) NSUInteger age;@property (nonatomic, assign) XXUserGender sex;+ (instancetype)modelWithIdentifier:(NSString *)identifier;- (void)login;@end 理解应用架构 MVC 和MVVM 的理解 Stack 和 Heap 分别的使用，如果管理？ ARC 是如何实现的？ Autorelease 对象何时释放？ AutoreleasePool 是如何实现的 理解Class 与对象模型 理解RunLoop 深入理解消息机制问题：从写入[obj foo] 这行代码知道运行时foo 被调用，尽量详细描述中间都发生了什么？ 12掌握：objc_msgSend 的关键调用，后续如何通过selector 从isa 找到IMP ,若运行时没有找到foo 会如何？精通：编译器如何编译成objc_msgSend、消息cache 机制、消息转发机制、objc_msgSend 的各个版本、objc_msgSend 的实现、跳板机制等 魔法数字12345//64位，下面会输出什么，为什么？- （void）magicNumberProblem&#123; //Tagged Pointer NSLog(@"%@",11529223390768879413UL);&#125; 输出sunny,在64位下，指针的空间很大，比实际指向的值还大，所以采用Tagged Pointer 机制，直接在指针的地址里存放值。 另辟蹊径的block 调用1234void (^block)(void) = ^&#123; NSLog(@"block get called");&#125;禁止调用block(); 答： 123[UIView animateWithDuration:1 animations:block];//ordispatch_async(dispatch_get_main_queue(), block); 1[[NSBlockOperation blockOperationWithBlock:block] start]; 123456789[[NSInvocation invocationWithMethodSignature:[NSMethodSignatrue signatureWithObjCTypes:"v@?"]] invokeWithTarget:block];//"v@?" 为block 的签名 v 表示返回值，@?表示第一个参数 为block 本身//NSInvocation 一般用法NSMethodSignature *signature = [self methodSignatureForSelector:@selector(description)];NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];invocation.target = self;invocation.selector = @selector(description);[invocation invoke]; 123456789//比较黑[block invoke];//block 是NSBlock 类型//经查找NSBlock 里有这些实例方法- (void)copy;- (void)copyWithZone:(&#123;_NSZone=&#125; *)arg0;- (void)invoke;- (void)performAfterDelay:(double)arg0; 12345678910111213//更黑//Block内部结构struct Block layout&#123; void *isa; volatile int32_t flag; int32_t reserved; void (*invoke)(void *,...); struct Block_descriptor_1 *descriptor;&#125;;void *pBlock = (__bridge void*)block;//取到block的首地址void (*invoke)(void *,...) = *((void **)pBlock + 2);//取到invoke函数的偏移量地址 32位加3invoke(pBlock); 12//节点__strong void(^cleaner)(void) __attribute__((cleanup(blockCleanUp), unused)) = block; 1asm("callq *0x10(%rax)");//汇编 真正调用方式 谈谈iOS 进阶 要去联想、理解、有自己的思考、对技术的主见 抽象、领悟、类比能力 看书、看博客、实战总结、刨根问底 进阶速度纯日常开发 &lt; 纯看书、博客 &lt; 自己试验、Demo &lt; 写博客 &lt; 系统性分享和讨论 &lt; 提供完整的开源方案 对技术保持好奇 对原理刨根问底 不甘于重复劳动 多思考，多怀疑 相信实践，不要轻信”大神”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective Objective-C 2.0 笔记]]></title>
      <url>%2F2016%2F10%2F24%2FEffective%20Objective-C%202.0%20%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[第一章1. Objective-C 使用的是消息结构而非函数调用，其区别在于： 消息结构的语言，其运行时所应执行的代码由运行环境决定，编译完并不知道应该执行哪个方法，即运行时绑定 函数调用的语言，由编译器决定，也就是编译完就知道应该执行那个方法 2.内存1NSString *someString = @"The String"; 对象所占内存总是分配在堆空间(heap space)，而绝不会分配在栈(stack)上。 1NSString *anotherString = someString; 两个变量都指向此实例，这说明当前栈帧(stack frame)里分配了两块内存，每块内存的大小都能容下一枚指针（在32位架构的计算机上是4字节，64位是8字节），这两块内存里的值都一样，就是NSString实例的内存地址。 分配在堆中的内存必须直接管理，分配在栈上的用于保存变量的内存则会在其栈帧弹出时自动清理 3.使用对象会比使用结构体性能差对象还需要额外的开销，例如分配及释放堆内存等 4.尽量使用@class 前向引用当只需要声明类型时，用@class 会避免编译.h 里不必要的东西，从而减少编译时间 5.多用字面量语法1NSNumber *someNumber = @7; 123456id object1 = /*...*/id object2 = /*...*/id object3 = /*...*/NSArray *arrayA = [NSArray arrayWithObjects:object1,object2,object3,nil];NSArray *arrayB = @[object1,object2,object3]; 如果object2 是nil,而arrayB 会crash ，但是arrayWithObjects 方法会依次处理各个参数，直到发现nil 为止，所以最终arrayA = @[ object1 ]，类似的方法还有dictionaryWithObjectsAndKeys: 6.多用类型常量，少用#define预处理指令例如定义一个动画时长 #define ANIMATION_DURATION 0.3 最好替换成 static const NSTimeInterval kAnimationDuration = 0.3; static表示其作用域仅限于当前的目标文件中，如果不加的话，如果其他编译单元也声明了同名变量，则编译器会抛出异常 如果只是在.m里定义的话，最好加上k 前缀，如果类外可见的话以类名为前缀 12extern NSString* const XXStringConstant; NSString* const XXStringConstant = @"XXStringConstant"; 此类常量放在全局符号表里，这里的XXStringConstant就是一个“一个常量，而这个常量是指针，指向NSString 对象” 第二章1.属性 @dynamic : 告诉编译器不需要生成存取方法 @synthesize : 合成属性 firstName = _firstName; weak : 非拥有的关系，所指对象遭到摧毁，属性也会清空(nil) unsafe_unretained : 当所指对象摧毁时，属性值不会自动清空 2.等同性 相同的对象必须具有相同的哈希值，但是两个哈希值相同的对象不一定相同 1234567891011NSMutableSet * set = [NSMutableSet new];NSArray *arr1 = @[@1,@2];NSArray *arr2 = @[@1];[set addobject:arr1];[set addobject:arr2]; //set &#123;(1,2),(1)&#125;[arr2 addObject:@(2)]; //set &#123;(1,2),(1,2)&#125; 哈希值改变了NSSet *set2 = [set copy]; // set &#123;(1,2)&#125; 3.类族模式类族模式可以把实现细节隐藏在一套简单的公共接口后面 1+ (UIButton* )buttonWithType:(UIButtonType)type; 该方法所返回的对象，其类型取决于传于传入的按钮类型，不管是什么类型，都是继承与UIButton; 4.在既既有类中使用关联对象存放自定义数据 “关联对象（Associated Object ）”存储策略 (Storage Policy) 关联类型 等效的@property 属性 OBJC_ASSOCIATION_ASSIGN assign OBJC_ASSOCIATION_RETAIN_NONATOMIC nonatomic,retain OBJC_ASSOCIATION_COPY_NONATOMIC nonatommic,copy OBJC_ASSOCIATION_RETAIN retain OBJC_ASSOCIATION_COPY copy 1void objc_setAssociatedObject(id object,void*key,id value,objc_AssociationPolicy policy) 以给定的键和策略为某对象设置关联对象值 1id objc_getAssociatedObject(id object,void*key) 根据给定的键和策略为某对象设置关联对象值 1void objc_removeAssociatedObjects(id object) 移除指定对象的全部关联对象 key: static void* associatedKey = @&quot;associatedKey&quot; 多次使用alert视图时，使用此方法较好 5.理解objc_msgSend 的作用1void objc_msgSend(id self, SEL cmd, ...) 这是个“参数个数可变的函数”，能接受两个或两个以上的参数。第一个参数代表接收者，第二个参数代表方法，后续参数就是消息中的那些参数 1id returnValue = [someObject messageName:parameter]; 编译器会将这个消息转换成如下函数： 1id returnValue = objc_msgSend(someObject, @selecter(messageName:), parameter) 该方法需要在接收者所属的类中搜寻其方法列表，如果能找到与方法名字相符的方法，就跳至其实现代码，若是找不到，那就沿着继承体系继续向上查找，等找到合适的方法之后再跳转。最终还是没有找到的话，那就执行消息转发。 objc_msgSend会将匹配结果缓存在快速映射表(fast map)里，每个类都有这样一块缓存，加快执行速度 6.理解消息转发机制在编译期向类发送了其无法解读的消息并不会报错，因为在运行期可以继续向类中添加方法，所以编译器在编译期还无法确定类中到底会不会有某个方法的实现。当对象接收到无法解读的消息后，就会启动消息转发机制，程序员可经此过程告诉对象应该如何处理未知消息。 消息转发分为两大阶段： 第一阶段先征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个未知的选择子，这叫做“动态方法解析” 第二阶段涉及“完整的消息转发机制”。如果runtime 已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择子的消息了，此时runtime 会请求接收者以其他手段来处理该消息。这又分为两小步： 首先，请接收者看看有没有其他对象能处理这条消息，若有，则runtime 会把这条消息转给那个对象，于是消息转发结束，一切如常。若没有“备援的接收者”，则启动完成的消息转发机制，runtime 会把与消息有关的全部细节封装到NSIvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息 动态方法解析对象在收到无法解读的消息后，首先将调用其所属类的下列类方法： 1+ (BOOL)resolveInstanceMethed:(SEL)selector; 表示这个类是否能新增一个实例方法用以处理此选择子。如果是类方法，runtime 会调用一个类似的方法，叫resolveClassMethod: 备援接收者第二次处理未知选择子的机会，runtime 会询问类：能不能把这条消息转给其他接收者来处理。 1- (id)forwardingTargetForSelector: (SEL)selector; 若当前接收者能找到备援对象，则将其返回，若找不到，返回nil。通过此方案，我们可以用“组合”来模拟出“多重继承”的某些特性。在一个对象的内部，可能还有一系列其他对象，该对象可经由此方法将能处理选择子的相关内部对象返回，在外界看来，好像是该对象亲自处理了消息。 完整的消息转发如果转发算法走到这一步，那么唯一能做的就是启用完整的消息转发机制了，首先创建NSIvocation 对象，把与尚未处理的那条消息有关的全部细节封于其中，此对象包含选择子，目标及参数。在触发NSInvocation 对象时，“消息派发系统”将亲自出马，把消息指派给目标对象。相当于只是改变了调用目标。 1-(void)forwardInvocation:(NSInvocation *)invocation; 继承体系中的每个类都有机会处理此调用请求，直至NSObject,继而调用doesNotRecognizeSelector:以抛出异常，表示最终未能得到处理。 ###消息转发全流程 方法调配技术 (Method swizzling)类的方法列表会把选择子的名称映射到相关的方法实现上，使得“动态消息派发系统”能够根据此找到应该调用的方法，这些方法均以函数指针的形式来表示，这种指针叫做IMP，原型如下： 1id (*IMP)(id, SEL, ...) runtime提供了一些方法来操作这张表 123Method originMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));Method swappedMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString));method_exchangeImplementations(originMethod, swappedMethod); 12345- (NSString* )my_lowercaseString&#123; NSString* lowercaser = [self my_lowercaseString]; NSLog(@"%@ =&gt; %@",self,lowercase); return lowercase;&#125; 将上面方法和NSString 的lowercaseString 方法互换，这段代码看上去会死循环，但是，在运行期间，my_lowercaseString 的选择子实际对应的是lowercaseString 。通常开发者可以在调试阶段利用这个方法来为那些“完全不知道实现细节”的方法增加日志记录功能，不宜滥用 7.理解 “类对象” 的用意id类型定义如下： 123typedef struct objc_object&#123; Class isa;// "is a"指针，定义了对象所属的类&#125; *id; Class 对象定义如下： 12345678910111213typedef struct objc_class *Classstruct objc_class&#123; Class isa;// "is a"指针，定义了对象所属的类 Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; struct obcj_cache *cache; struct objc_protocol_list *protocols;&#125;; 类对象所属的类型叫做元类，用来表述类对象本身所具备的元数据。每个类既有一个“类对象”，而每个“类对象”仅有一个与之相关的“元类”。 继承体系如下： 比较对象是否等同除了 isKindOfClass:还可以用比较类对象是否相同，原因在于，类对象是“单例”，每个类的Class 仅有一个实例。 1234id object = /* ... */;if ([object class] == [SomeClass class])&#123; // 'object is an instance of SomeClass'&#125; 虽然能这样比较，但不推荐。例如，某个对象可能会把其收到的所有选择子都转发到另一个对象。这样的对象叫做“代理(proxy)“，此种对象均以NSProxy 为根类。如果在这种对象上调用class 方法，那么返回的是代理对象本身(此类是NSProxy 的子类)，而非接受代理的对象所属的类，然而改用isKindOfClass:就能把这条消息转给接受代理的对象。 8.Block1.块的内部结构块本身也是对象，在存放块对象的内存区域中，首个变量是指向Class 对象的指针，叫做isa ，其余内存里含有块对象正常运转所需的各种信息。 void* isa int flags int reserved void ()(void ,…) invoke struct * descriptor 捕获到的变量 其中最重要的就是invoke 变量，这是个函数指针，指向块的实现代码。函数原型至少要接受一个void* 型的参数，此参数代表块。descriptor 变量是指向结构体的指针，其中声明了块对象的总体的大小，还声明了copy 与dispose 这两个辅助函数所对应的函数指针。descriptor 对应结构如下： unsigned long int reserved unsigned long int size void ()(void , void *) copy void ()(void , void *) dispose 块还会把它所捕获的所有变量都拷贝一份，这些拷贝都放在descriptor 变量后面，捕获了多少个变量，就要占据多少内存空间。注意，拷贝的并不是对象本身，而是指向这些对象的指针变量。invoke 函数之所以把块当第一个参数传递进来，原因在于，执行块时，要从内存中把这些捕获的变量读出来。 2.全局块、栈块及堆块定义块的时候，其所占内存区域是分配在占栈中，块只在定义它的那个范围内有效。 1234567891011void (^Block)();if (/* some condition*/)&#123; block = ^&#123; NSLog(@"Block A"); &#125;;&#125;else&#123; block = ^&#123; NSLog(@"Block B"); &#125;&#125;block(); 这段代码就有危险，定义在if 里面的Block 都分配在栈内存中。在离开了if 语句后，编译器有可能把分配在块的内存覆写掉，可能导致crash。为解决此问题，可以给块对象发送copy 消息来拷贝，这样可以把块从栈复制到堆上，块就成了带引用计数的对象了。后续的拷贝操作都不会真的执行复制，只是递增块对象的引用计数。 1234567891011void (^Block)();if (/* some condition*/)&#123; block = [^&#123; NSLog(@"Block A"); &#125; copy];&#125;else&#123; block = [^&#123; NSLog(@"Block B"); &#125; copy]&#125;block(); 3.全局块123void (^Block)() = ^&#123; NSLog(@"This is a block"); &#125; 由于在编译期能确定块所需的全部信息，所以可以把它做成全局块。这是种优化技术。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[起步]]></title>
      <url>%2F2016%2F10%2F21%2F%E8%B5%B7%E6%AD%A5%2F</url>
      <content type="text"><![CDATA[起步这是使用MWeb 写的第一篇文章。从事iOS 开发一年多了，一直也没有系统地整理所学的知识以及记录踩过的坑，在公司里一直也只是在做业务需求，没有涉及大多设计模式，底层框架的东西，感觉自己一直没有什么提升。所以决定开始写点什么，向大牛学习，可能文章质量不怎么高，但还是希望自己能从iOS 开发菜鸟稍微进阶一下。 计划 买的Effective Objective-C 2.0 书，还没有看完，准备将书里的知识点总结一下 总结一下几天前在趣直播平台上我就叫Sunny怎么了 的iOS 面试小灶直播内容 加油先把计划的这两件事做好，还是要静下心一步步来，慢慢积累吧。你还差的远呢！]]></content>
    </entry>

    
  
  
</search>
